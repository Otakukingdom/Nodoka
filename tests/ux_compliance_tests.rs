//! UX compliance tests - verify adherence to design system guidelines
//!
//! These tests validate that the UI follows UX best practices from
//! the design system generated by ui-ux-pro-max skill.

#![allow(clippy::assertions_on_constants)]
#![allow(clippy::float_cmp)]

use nodoka::ui::*;

#[test]
fn test_spacing_follows_4px_grid() {
    // Verify all spacing constants are multiples of 4
    assert_eq!(spacing::XS % 4.0, 0.0, "XS spacing should be multiple of 4");
    assert_eq!(spacing::SM % 4.0, 0.0, "SM spacing should be multiple of 4");
    assert_eq!(spacing::MD % 4.0, 0.0, "MD spacing should be multiple of 4");
    assert_eq!(spacing::LG % 4.0, 0.0, "LG spacing should be multiple of 4");
    assert_eq!(spacing::XL % 4.0, 0.0, "XL spacing should be multiple of 4");
    assert_eq!(
        spacing::XXL % 4.0,
        0.0,
        "XXL spacing should be multiple of 4"
    );
}

#[test]
fn test_typography_scale_monotonic() {
    // Verify typography sizes increase monotonically
    assert!(
        typography::SIZE_XS < typography::SIZE_SM,
        "XS should be smaller than SM"
    );
    assert!(
        typography::SIZE_SM < typography::SIZE_BASE,
        "SM should be smaller than BASE"
    );
    assert!(
        typography::SIZE_BASE < typography::SIZE_LG,
        "BASE should be smaller than LG"
    );
    assert!(
        typography::SIZE_LG < typography::SIZE_XL,
        "LG should be smaller than XL"
    );
    assert!(
        typography::SIZE_XL < typography::SIZE_XXL,
        "XL should be smaller than XXL"
    );
    assert!(
        typography::SIZE_XXL < typography::SIZE_HEADING,
        "XXL should be smaller than HEADING"
    );
}

#[test]
fn test_transition_durations_within_ux_guidelines() {
    // UX guideline: transitions should be 150-300ms for optimal feel
    assert!(
        transitions::FAST >= 150,
        "FAST transition should be >= 150ms"
    );
    assert!(
        transitions::FAST <= 300,
        "FAST transition should be <= 300ms"
    );
    assert!(
        transitions::NORMAL >= 150,
        "NORMAL transition should be >= 150ms"
    );
    assert!(
        transitions::NORMAL <= 300,
        "NORMAL transition should be <= 300ms"
    );
    assert!(
        transitions::SLOW >= 150,
        "SLOW transition should be >= 150ms"
    );
    assert!(
        transitions::SLOW <= 300,
        "SLOW transition should be <= 300ms"
    );
}

#[test]
fn test_border_radius_consistency() {
    // Border radius should increase monotonically
    assert!(
        border_radius::SM < border_radius::MD,
        "SM radius should be smaller than MD"
    );
    assert!(
        border_radius::MD < border_radius::LG,
        "MD radius should be smaller than LG"
    );
    assert!(
        border_radius::LG < border_radius::XL,
        "LG radius should be smaller than XL"
    );
}

#[test]
fn test_color_palette_consistency() {
    // Verify primary color variants are related
    // PRIMARY_HOVER should be darker than PRIMARY
    let primary = colors::PRIMARY;
    let primary_hover = colors::PRIMARY_HOVER;
    let primary_active = colors::PRIMARY_ACTIVE;

    // Check RGB components decrease (getting darker)
    assert!(
        primary_hover.r < primary.r,
        "PRIMARY_HOVER red should be darker"
    );
    assert!(
        primary_active.r < primary_hover.r,
        "PRIMARY_ACTIVE red should be darker than hover"
    );
}

#[test]
fn test_typography_base_size_readability() {
    // Base text size should be at least 14px for readability
    assert!(
        typography::SIZE_BASE >= 14.0,
        "Base text size should be at least 14px for readability"
    );
}

#[test]
fn test_spacing_scale_reasonable_ratios() {
    // Spacing scale should have reasonable ratios (roughly 2x between steps)
    let ratio_xs_sm = spacing::SM / spacing::XS;
    let ratio_sm_md = spacing::MD / spacing::SM;
    let ratio_md_lg = spacing::LG / spacing::MD;
    let ratio_lg_xl = spacing::XL / spacing::LG;

    // Ratios should be between 1.5x and 2.5x for good visual rhythm
    assert!(
        (1.5..=2.5).contains(&ratio_xs_sm),
        "XS to SM ratio should be reasonable: {ratio_xs_sm}"
    );
    assert!(
        (1.5..=2.5).contains(&ratio_sm_md),
        "SM to MD ratio should be reasonable: {ratio_sm_md}"
    );
    assert!(
        (1.5..=2.5).contains(&ratio_md_lg),
        "MD to LG ratio should be reasonable: {ratio_md_lg}"
    );
    assert!(
        (1.0..=2.0).contains(&ratio_lg_xl),
        "LG to XL ratio should be reasonable: {ratio_lg_xl}"
    );
}

#[test]
fn test_color_transparency_values() {
    // Verify overlay colors have appropriate alpha values
    let hover = colors::HOVER_OVERLAY;
    let active = colors::ACTIVE_OVERLAY;

    // Hover should be subtle (5% opacity)
    assert!(
        (0.04..=0.06).contains(&hover.a),
        "Hover overlay should be around 5% opacity"
    );

    // Active should be more visible (10% opacity)
    assert!(
        (0.09..=0.11).contains(&active.a),
        "Active overlay should be around 10% opacity"
    );

    // Active should be darker than hover
    assert!(
        active.a > hover.a,
        "Active overlay should be darker than hover"
    );
}

#[test]
fn test_focus_ring_visibility() {
    // Focus ring should be blue and distinct from other colors
    let focus = colors::FOCUS_RING;

    // Should be bluish (higher blue component)
    assert!(focus.b > focus.r, "Focus ring should be blue-dominant");
    assert!(focus.b > focus.g, "Focus ring should be blue-dominant");
}

#[test]
fn test_error_color_visibility() {
    // Error colors should be distinct and attention-grabbing
    let error = colors::ERROR;

    // Error color should have high red component
    assert!(
        error.r > 0.7,
        "Error color should be red-dominant: {:.2}",
        error.r
    );
}

#[test]
fn test_format_duration_consistency() {
    // Test that duration formatting is consistent
    assert_eq!(format_duration(Some(1000)), "0:01");
    assert_eq!(format_duration(Some(60_000)), "1:00");
    assert_eq!(format_duration(Some(3_600_000)), "1:00:00");
    assert_eq!(format_duration(None), "--:--");
    // Zero or negative durations show as "--:--"
    assert_eq!(format_duration(Some(0)), "--:--");
}

#[test]
fn test_format_time_ms_consistency() {
    // Test that time formatting is consistent
    assert_eq!(format_time_ms(0), "0:00");
    assert_eq!(format_time_ms(1000), "0:01");
    assert_eq!(format_time_ms(60_000), "1:00");
    assert_eq!(format_time_ms(3_600_000), "1:00:00");
}

#[test]
fn test_selection_colors_contrast() {
    // Selection background and text should have good contrast
    let selection_bg = colors::SELECTION_BG;
    let selection_text = colors::SELECTION_TEXT;

    // Background should be darker, text should be lighter
    assert!(
        selection_bg.r < selection_text.r
            || selection_bg.g < selection_text.g
            || selection_bg.b < selection_text.b,
        "Selection text should contrast with background"
    );
}
