//! UX compliance tests - verify adherence to design system guidelines
//!
//! These tests validate that the UI follows UX best practices from
//! the design system generated by ui-ux-pro-max skill.

use nodoka::ui::*;

#[test]
fn test_spacing_follows_4px_grid() {
    // Verify all spacing constants are multiples of 4
    fn multiple_of_4(value: f32) -> bool {
        let scaled = value / 4.0;
        (scaled - scaled.round()).abs() < 1e-6
    }

    assert!(
        multiple_of_4(spacing::XS),
        "XS spacing should be multiple of 4"
    );
    assert!(
        multiple_of_4(spacing::SM),
        "SM spacing should be multiple of 4"
    );
    assert!(
        multiple_of_4(spacing::MD),
        "MD spacing should be multiple of 4"
    );
    assert!(
        multiple_of_4(spacing::LG),
        "LG spacing should be multiple of 4"
    );
    assert!(
        multiple_of_4(spacing::XL),
        "XL spacing should be multiple of 4"
    );
    assert!(
        multiple_of_4(spacing::XXL),
        "XXL spacing should be multiple of 4"
    );
}

#[test]
fn test_typography_scale_monotonic() {
    // Compile-time guarantee for a constant typography scale.
    const {
        assert!(typography::SIZE_XS < typography::SIZE_SM);
        assert!(typography::SIZE_SM < typography::SIZE_BASE);
        assert!(typography::SIZE_BASE < typography::SIZE_LG);
        assert!(typography::SIZE_LG < typography::SIZE_XL);
        assert!(typography::SIZE_XL < typography::SIZE_XXL);
        assert!(typography::SIZE_XXL < typography::SIZE_HEADING);
    }
}

#[test]
fn test_transition_durations_within_ux_guidelines() {
    // Compile-time guarantee for a constant transition scale.
    const {
        assert!(transitions::FAST >= 150);
        assert!(transitions::FAST <= 300);
        assert!(transitions::NORMAL >= 150);
        assert!(transitions::NORMAL <= 300);
        assert!(transitions::SLOW >= 150);
        assert!(transitions::SLOW <= 300);
    }
}

#[test]
fn test_border_radius_consistency() {
    // Compile-time guarantee for a constant border radius scale.
    const {
        assert!(border_radius::SM < border_radius::MD);
        assert!(border_radius::MD < border_radius::LG);
        assert!(border_radius::LG < border_radius::XL);
    }
}

#[test]
fn test_color_palette_consistency() {
    // Verify primary color variants are related
    // PRIMARY_HOVER should be darker than PRIMARY
    let primary = colors::PRIMARY;
    let primary_hover = colors::PRIMARY_HOVER;
    let primary_active = colors::PRIMARY_ACTIVE;

    // Check RGB components decrease (getting darker)
    assert!(
        primary_hover.r < primary.r,
        "PRIMARY_HOVER red should be darker"
    );
    assert!(
        primary_active.r < primary_hover.r,
        "PRIMARY_ACTIVE red should be darker than hover"
    );
}

#[test]
fn test_typography_base_size_readability() {
    // Compile-time guarantee for readable base text size.
    const {
        assert!(typography::SIZE_BASE >= 14.0);
    }
}

#[test]
fn test_spacing_scale_reasonable_ratios() {
    // Spacing scale should have reasonable ratios (roughly 2x between steps)
    let ratio_xs_sm = spacing::SM / spacing::XS;
    let ratio_sm_md = spacing::MD / spacing::SM;
    let ratio_md_lg = spacing::LG / spacing::MD;
    let ratio_lg_xl = spacing::XL / spacing::LG;

    // Ratios should be between 1.5x and 2.5x for good visual rhythm
    assert!(
        (1.5..=2.5).contains(&ratio_xs_sm),
        "XS to SM ratio should be reasonable: {ratio_xs_sm}"
    );
    assert!(
        (1.5..=2.5).contains(&ratio_sm_md),
        "SM to MD ratio should be reasonable: {ratio_sm_md}"
    );
    assert!(
        (1.5..=2.5).contains(&ratio_md_lg),
        "MD to LG ratio should be reasonable: {ratio_md_lg}"
    );
    assert!(
        (1.0..=2.0).contains(&ratio_lg_xl),
        "LG to XL ratio should be reasonable: {ratio_lg_xl}"
    );
}

#[test]
fn test_color_transparency_values() {
    // Verify overlay colors have appropriate alpha values
    let hover = colors::HOVER_OVERLAY;
    let active = colors::ACTIVE_OVERLAY;

    // Hover should be subtle (5% opacity)
    assert!(
        (0.04..=0.06).contains(&hover.a),
        "Hover overlay should be around 5% opacity"
    );

    // Active should be more visible (10% opacity)
    assert!(
        (0.09..=0.11).contains(&active.a),
        "Active overlay should be around 10% opacity"
    );

    // Active should be darker than hover
    assert!(
        active.a > hover.a,
        "Active overlay should be darker than hover"
    );
}

#[test]
fn test_focus_ring_visibility() {
    // Focus ring should be blue and distinct from other colors
    let focus = colors::FOCUS_RING;

    // Should be bluish (higher blue component)
    assert!(focus.b > focus.r, "Focus ring should be blue-dominant");
    assert!(focus.b > focus.g, "Focus ring should be blue-dominant");
}

#[test]
fn test_error_color_visibility() {
    // Error colors should be distinct and attention-grabbing
    let error = colors::ERROR;

    // Error color should have high red component
    assert!(
        error.r > 0.7,
        "Error color should be red-dominant: {:.2}",
        error.r
    );
}

#[test]
fn test_format_duration_consistency() {
    // Test that duration formatting is consistent
    assert_eq!(format_duration(Some(1000)), "0:01");
    assert_eq!(format_duration(Some(60_000)), "1:00");
    assert_eq!(format_duration(Some(3_600_000)), "1:00:00");
    assert_eq!(format_duration(None), "--:--");
    // Zero or negative durations show as "--:--"
    assert_eq!(format_duration(Some(0)), "--:--");
}

#[test]
fn test_format_time_ms_consistency() {
    // Test that time formatting is consistent
    assert_eq!(format_time_ms(0), "0:00");
    assert_eq!(format_time_ms(1000), "0:01");
    assert_eq!(format_time_ms(60_000), "1:00");
    assert_eq!(format_time_ms(3_600_000), "1:00:00");
}

#[test]
fn test_selection_colors_contrast() {
    // Selection background and text should have good contrast
    let selection_bg = colors::SELECTION_BG;
    let selection_text = colors::SELECTION_TEXT;

    // Background should be darker, text should be lighter
    assert!(
        selection_bg.r < selection_text.r
            || selection_bg.g < selection_text.g
            || selection_bg.b < selection_text.b,
        "Selection text should contrast with background"
    );
}
